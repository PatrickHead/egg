\input texinfo
@c -*-texinfo-*-
@c %**start of header
@setfilename egg.info
@include version.texi
@smallbook
@settitle EGG User Guide (@value{VERSION})
@c %**end of header


@copying
This manual is the User Guide for EGG (version @value{VERSION}).

Copyright @copyright{} 2013 Patrick Head.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts. A copy of the license is included in the section entitled
``GNU Free Documentation License''.
@end quotation
@end copying

@titlepage
@title Egg User Guide (ver. 0.2.2)

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@iftex
@c preface BEGIN
@node Preface
@page
@chapheading Preface
(the motivation for this document, and EGG itself)
@c preface END
@end iftex

@c introduction BEGIN
@node Introduction,EGG Explained,Top,Top
@page
@chapheading Introduction
EGG is several things.  Firstly, EGG is the name of a very specific and strictly defined BNF style grammar definition language.   Secondly, the name EGG is loosely an acronym for Expression Grammar, Grammer.  This acronym is neither exactly precise, nor official.  The name EGG is mostly intended to imply the beginning of something, particularly the beginning of a formal grammar, which can grow into a complete parser for that grammar.

EGG also serves as the foundation, a starting point, for creating a precisely defined grammar.  From this grammar definition, the source code for a parser can be generated.

This User Guide contains the official documention for the EGG language itself, and  the usage documentation for three associated utilities -- embryo, egg-walker, and egg-mapper.  These three utilities are the standard parser code generator, and associated grammar checking and diagramming utilities.  Details for the usage and command line options for each of these utilities is documented.  Additionally, the output that each of these utilities produces is explained in detail.

A step-by-step tutorial is included in this User Guide, to serve as both a grammar writing guide for EGG definitions, and to illustrate the work flow for generating a parser from the grammar that is defined in EGG.

Each chapter in this User Guide contains a high level statement of purpose, which is followed by sections that progressively get more detailed in nature.  For a first time reader of this User Guide, and especially for those new to BNF style grammar definition languages, it is suggested that reading the introductory sections of each chapter, and perusing the examples sections may provide a more meaningful learning experience.

It is likely that the example sections of each chapter, and the tutorial chapter will be all that is necessary to get a working knowledge of how to implement a grammar in EGG and build a parser for that grammar.
@c introduction END

@c table-of-contents BEGIN
@contents
@c table-of-contents END

@c Menu required for info/HTML and other formats
@ifnottex
@node Top,Introduction,(dir),(dir)
@top Egg User Guide (@value{VERSION})
Egg User Guide (@value{VERSION})
@end ifnottex
@menu
* Introduction::     Introduction to EGG
* EGG Explained::    History and detailed explanation of EGG grammars
* embryo::           embryo command details
* embryo Output Explained::  Source code generation explained
* egg-walker::       egg-walker command details
* egg-walker Output Explained::  Token tree explained
* egg-mapper::       egg-mapper command details
* egg-mapper Output Explained::  Grammar reference map explained
* Tutorial - Creating a parser from an EGG::  Step-by-step tutorial for EGG usage.
* Terms::            Some EGG terminology defined
* Bibliography::     References
* Index::            Complete index
@end menu

@node EGG Explained,embryo,Introduction,Top
@chapter EGG Explained
@cindex chapter, EGG Explained
@menu
* Brief History::
* Purpose and Design Goals::
* Elements of the EGG Syntax::
* An Example Grammar Defined in EGG::
@end menu

@node Brief History
@section Brief History
In the late 1950s and early 1960s, much innovative work was being performed in the area of computer language development and formalization.  Borrowing from other works in areas such as mathematics and linguistics, John Backus, while working on the computer programming language ALGOL, proposed a method of precisely defining the grammar of ALGOL and its syntax.  Peter Naur later suggested this notation become known as Backus Normal Form.  Donald Knuth later proprosed that the name of this notation be Backus-Naur Form, as the notation was not strictly a "normal" form, as defined in computing, and because Naur also contributed to its refinement.

Backus-Naur Form has since been adopted as a major notation for defining most any computer progamming language, as well as data structures, instruction sets for processors and virtual machines and other concepts.  Backus-Naur Form is commonly known by its acronym, BNF.

BNF is a way of describing what are known as context free grammars.  To qualify as a context free grammar, a grammar must be able to be described by what are known as production rules.  Production rules are simply a way of stating that some named thing on the left side of the rule can be replaced by a thing or series of things on the right side of the rule.  What are the things in such production rules?  On the left side of the rule is the name of the rule itself, which is an abstract concept.  On the right side of the rule, a single or series of terminal values (many times literal values), and/or names of other grammar rules can exist.

  A production rule can best be illustrated by example:

    <number> ::= <digit> | <digit> <number>

    <digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

In the above example we have two production rules.   The first rule <number> is defined as either a single digit, or a digit followed by another <number>.  The net effect of this rule is that a number is any sequence of 1 or more digits.  The second rule <digit> is defined as one of either a literal '0' character, or a literal '1' character, or a literal '2' character, and so forth.

Two important concepts exist in the <digit> rule.  First the concept is that of alternation in a rule.  A rule can match something, or something else, etc.  The second concept is that of a terminal value.  Terminal values are those items that can not be further defined by additional production rules.  Typically these are literal characters as in the above example, or strings of characters, such as 'PRINT'.  Terminals may also indicate a class of characters, such as <digit> which itself is left up to some external mechanism to provide. Terminals are also described as being atomic.  They can not be broken down any further.

Over time, many variants of BNF have been proposed, and some have been formalized into international standards, such as EBNF and ABNF.  Most of these variants address some of the perceived short comings of the original BNF.  Namely, the very non-intuitive syntax of indicating "or more" by including a recursive element in a right side rule definition.  In the above example a "| <digit> <number>" fragment is used, which in BNF means a digit followed by another number, which of course can expand to an infinitely long sequence of digits.

Also, defining a quantified sequence of items in a BNF production rule is cumbersome at best.  For instance, to define that a product code can be a sequence of 2, 3, 4, or 5 digits, a BNF rule would look like this:

    <product code> ::= <digit> <digit>
                     | <digit> <digit> <digit>
                     | <digit> <digit> <digit> <digit>
                     | <digit> <digit> <digit> <digit> <digit>

Another possible issue with the original BNF is that rule names are denoted by the '<' and '>' brackets.  This in itself is not a problem, but then an ambiguity arises when a terminal character is a literal '<' or '>' character.  For instance:
    <special instruction> ::= <bold>

Does the above rule mean that <special instruction> is an instance of another
  rule named <bold>, or is it the literal sequence of characters '<', followed by 'bold' and '>'?
 
Also, since terminal characters in BNF are simply unadorned in any way, the grammars that BNF define are limited to the ASCII character set, or something very
similar such as EBCDIC, as literal characters.

These shortcomings, both perceived and real, have led to many different variants of BNF.  Some variants are formal, such as the aforementioned EBNF and ABNF.  Some are simply convenient alternatives for internal usage in a given organization or project.  Almost all of the BNF variants are attempts to make grammar definition more concise, with fewer production rules, or more readable, or to eliminate ambiguities, or to add other conveniences to the BNF definition.

This leads us to EGG, which is dubbed by the creator of EGG as "Yet Another BNF."  YAB was actually considered as a name for EGG, but has potentially unpleasant connotations in some human languages and circles, so EGG was chosen as the official name.

@node Purpose and Design Goals
@section Purpose and Design Goals
The intent of EGG is to define a BNF style language that satisfies two design requirements.

    -  EGG is designed to be easy to read and understand.
    -  EGG is designed to be used in the automatic production of parser source code.
@menu
* Syntax Simplification::
* Parser Source Code Generation::
@end menu

@node Syntax Simplification
@subsection Syntax Simplification
While any well formed BNF is capable of defining a grammar, one of the main design goals of EGG is to add a few syntactic elements to make defining a quantified number of items in a sequence reasonably easy to understand.  In addition, another design goal of EGG is to eliminate alternative ways of describing a grammar element or phrase.  For instance, some BNF systems may allow an asterisk ('*') to indicate zero or more instances of the preceding grammar item.   That same BNF system may also allow a more specific quantifier syntax, such as 'item[2-5]', which may indicate that two through five instances of item may occur in a sequence.

Allowing both styles of quantification shortcutting syntax, while convenient, is redundant.  EGG eliminates this type of redundant syntax.  In EGG, there is generally only one syntactically correct way to describe a grammar element.

A side effect of the simplified nature of the EGG syntax is to promote consistent ways of defining different types of grammar constructs.  For instance, in EGG, there are no specific grouping operators, therefore only a single grammar item can be quantified.  This eliminates alternative and redundant styles of defining quantified sequences.  In EGG, a quantified sequence must first be defined as a phrase (rule) containing the sequence, then referenced by name in another phrase with a quantifier.

@node Parser Source Code Generation
@subsection Parser Source Code Generation
From its conception, EGG was designed to assist in the automatic generation of parser source code.  This source code can then be included in a larger project.  Several design decisions for the syntax of EGG have been made which balance the requirements of an author of a grammar with the requirements for automatically generating source code from that grammar.

EGG is designed to produce recursive descent style parsers, but nothing in the EGG language should preclude the generation of other types of parsers.

@node Elements of the EGG Syntax
@section Elements of the EGG Syntax
From a high level, the syntax of EGG is fairly simple and straightforward.  In this section, each element of the EGG grammar itself will be explained in detail.

The most fundamental element of an EGG grammar definition is what is formally
named a phrase.  A phrase consists of a phrase name (phrase-name), followed
by an equal sign ('='), followed by a definition, followed by a terminating
semicolon (';').

EGG itself is canonically defined using the EGG language.  Each phrase that makes up the entirety of the EGG grammar is detailed below.

The EGG grammar is broken down into a few basic sections.

@iftex
@quotation
@itemize
@item
Grammar Structure
@item
Types
@item
Symbols
@item
Character Classes
@item
ASCII Character Set
@end itemize
@end quotation
@end iftex

@menu
* Grammar Structure::
* Types::
* Symbols::
* Character Classes::
* ASCII Character Set::
@end menu

@node Grammar Structure
@subsection Grammar Structure
Grammar Structure elements are likely the only elements that an author
of a grammar using EGG will need to understand.  The additional phrases
which define EGG are useful in formalizing the syntactic details
of an EGG grammar.  A grasp of these Grammar Structure elements
should yield a reasonably intuitive understanding of a grammar defined in EGG.

@quotation
@table @code
@item grammar
zero or more @code{grammar-elements},
followed by zero or one @code{non-grammar-element}

This is the foundational phrase for the EGG grammar.  It encompasses the
entire collection of phrases that make up an EGG grammar.

@item grammar-element
zero or one @code{non-grammar-element},
followed by @code{phrase}

This phrase allows non essential parts of an EGG definition to exist, such
as comments and white space proceeding other phrase definitions.

@item phrase
@code{phrase-name},
followed by zero or one @code{non-grammar-element},
followed by @code{equal},
followed by zero or one @code{non-grammar-element},
followed by @code{definition},
followed by zero or one @code{non-grammar-element},
followed by @code{semicolon}

This is the most fundamental definition of the EGG grammar. All EGG
grammar definitions are composed of a collection of phrases.

@item definition
@code{sequence},
followed by zero or more @code{definition-continuation}

@item definition-continuation
zero or one @code{non-grammar-element},
followed by @code{alternation-symbol},
followed by zero or one @code{non-grammar-element},
followed by @code{sequence}

@item sequence
@code{item},
followed by zero or more @code{sequence-continuation}

@item sequence-continuation
zero or one @code{non-grammar-element},
followed by @code{concatenation-symbol},
followed by zero or one @code{non-grammar-element},
followed by @code{item} 

@item item
@code{atom},
followed by zero or one @code{quantifier}

@item atom
one of @code{literal}, or @code{phrase-name}

@end table
@end quotation

@node Types
@subsection Types
These phrases formalize and refine the syntax for individual EGG elements,
such as how a quantifier, phrase-name or literal is expressed.

@quotation
@table @code
@item quantifier
@code{open-brace},
followed by @code{integer},
followed by zero or one @code{quantifier-option},
followed by @code{close-brace}

@item quantifier-option
@code{comma}, followed by @code{quantifier-item}

@item quantifier-item
one of @code{integer}, or @code{asterisk}

@item phrase-name
@code{letter}, followed by zero or one @code{phrase-name-character}

@item non-grammar-element
one or more @code{non-grammar-item}

@item non-grammar-item
one of @code{control-character}, or @code{illumination}

@item illumination
one of @code{white-space}, or @code{comment}

@item comment
@code{comment-start-symbol}, followed by zero or more @code{comment-item}, followed by @code{comment-end-symbol}

@item comment-item
one of @code{comment}, or @code{comment-character}

@item literal
one of @code{single-quoted-literal}, @code{quoted-literal}, or @code{absolute-literal}

@item single-quoted-literal
@code{single-quote}, followed by one or more @code{single-quoted-character}, followed by @code{single-quote}

@item quoted-literal
@code{quote}, followed by one or more @code{quoted-character}, followed by a @code{quote}

@item absolute-literal
@code{slash}, followed by zero or more @code{space}, followed by @code{integer}, followed by zero or more @code{space}, followed by @code{slash}

@item integer
one of @code{binary-integer}, @code{octal-integer}, @code{hexadecimal-integer}, or @code{decimal-integer}

@item binary-integer
@code{zero}, followed by @code{binary-indicator}, followed by one or more @code{binary-digit}

@item octal-integer
@code{zero}, followed by @code{octal-indicator}, followed by one or more @code{octal-digit}

@item hexadecimal-integer
@code{zero}, followed by @code{hexadecimal-indicator}, followed by one or more @code{hexadecimal-digit}

@item decimal-integer
one or more @code{decimal-digit}

@end table
@end quotation

@node Symbols
@subsection Symbols
These phrases define a few specific symbol elements in the EGG grammar that
either are more than one character long, or are an integral and common
part of the EGG grammar.

@quotation
@table @code
@item comment-start-symbol
@code{open-parenthesis}, followed by @code{asterisk}

@item comment-end-symbol
@code{asterisk}, followed by @code{close-parenthesis}

@item alternation-symbol
@code{bar}

@item concatenation-symbol
@code{plus}

@item phrase-terminator-symbol
@code{semicolon}

@end table
@end quotation

@node Character Classes
@subsection Character Classes
These phrases define some commonly used classes (groupings) of characters that
are useful in other EGG grammar elements, such as a @code{phrase-name},
an @code{integer}, etc.

@quotation
@table @code
@item control-character
one of @code{nul}, @code{soh}, @code{stx}, @code{etx}, @code{eot}, @code{enq}, @code{ack}, @code{bel}, @code{bs}, @code{so}, @code{si}, @code{dle}, @code{dc1}, @code{dc2}, @code{dc3}, @code{dc4}, @code{nak}, @code{syn}, @code{etb}, @code{can}, @code{em}, @code{sub}, @code{esc}, @code{fs}, @code{gs}, @code{rs}, @code{us}, or @code{del}

@item upper-case-character
one of @code{A}, @code{B}, @code{C}, @code{D}, @code{E}, @code{F}, @code{G}, @code{H}, @code{I}, @code{J}, @code{K}, @code{L}, @code{M}, @code{N}, @code{O}, @code{P}, @code{Q}, @code{R}, @code{S}, @code{T}, @code{U}, @code{V}, @code{W}, @code{X}, @code{Y}, or @code{Z}

@item lower-case-character
one of @code{a}, @code{b}, @code{c}, @code{d}, @code{e}, @code{f}, @code{g}, @code{h}, @code{i}, @code{j}, @code{k}, @code{l}, @code{m}, @code{n}, @code{o}, @code{p}, @code{q}, @code{r}, @code{s}, @code{t}, @code{u}, @code{v}, @code{w}, @code{x}, @code{y}, OR @code{z}

@item letter
one of @code{upper-case-letter}, or @code{lower-case-letter}

@item binary-digit
one of @code{zero}, or @code{one}

@item octal-digit
one of @code{zero}, @code{one}, @code{two}, @code{three}, @code{four}, @code{five}, @code{six}, or @code{seven}

@item decimal-digit
one of @code{zero}, @code{one}, @code{two}, @code{three}, @code{four}, @code{five}, @code{six}, @code{seven}, @code{eight} or @code{nine}

@item hexadecimal-digit
one of @code{zero}, @code{one}, @code{two}, @code{three}, @code{four}, @code{five}, @code{six}, @code{seven}, @code{eight}, @code{nine}, @code{A}, @code{B}, @code{C}, @code{D}, @code{E}, @code{F}, @code{a}, @code{b}, @code{c}, @code{d}, @code{e}, or @code{f}

@item white-space
one of @code{space}, @code{ht}, @code{lf}, @code{vt}, @code{ff}, or @code{cr}

@item common-character
one of @code{exclamation-point}, @code{number-sign}, @code{dollar}, @code{percent}, @code{ampersand}, @code{plus}, @code{comma}, @code{minus}, @code{period}, @code{colon}, @code{semicolon}, @code{less-than}, @code{equal}, @code{greater-than}, @code{question-mark}, @code{at}, @code{open-bracket}, @code{back-slash}, @code{close-bracket}, @code{carat}, @code{underscore}, @code{back-quote}, @code{open-brace}, @code{bar}, @code{close-brace}, @code{tilde}, @code{letter}, or @code{decimal-digit}

@item literal-character
one of @code{common-character}, @code{space}, @code{open-parenthesis}, @code{close-parenthesis}, or @code{asterisk}

@item comment-basic-character
one of @code{common-character}, @code{white-space}, @code{quote}, @code{single-quote}, or @code{slash}

@item non-comment-start-character
one of @code{comment-basic-character}, or @code{close-parenthesis}

@item non-comment-end-character
one of @code{comment-basic-character}, or @code{open-parenthesis}

@item non-comment-start-sequence
@code{open-parenthesis}, followed by @code{non-comment-start-character}

@item non-comment-end-sequence
@code{asterisk}, followed by @code{non-comment-end-character}

@item comment-character
one of @code{comment-basic-character}, @code{non-comment-start-sequence}, @code{non-comment-end-sequence}, or @code{close-parenthesis}

@item single-quoted-character
one of @code{literal-character}, or @code{quote}

@item quoted-character
one of @code{literal-character}, or @code{single-quote}

@item phrase-conjugator
one of @code{underscore}, or @code{minus}

@item phrase-name-character
one of @code{letter}, @code{decimal-digit}, or @code{phrase-conjugator}

@item binary-indicator
one of @code{b}, or @code{B}

@item octal-indicator
one of @code{o}, or @code{O}

@item hexadecimal-indicator
one of @code{x}, or @code{X}

@end table
@end quotation

@node ASCII Character Set
@subsection ASCII Character Set
The EGG definition includes phrases for each of the 128 ASCII characters
defined in the ASCII character set.  This has two disctinct implications.

The first implication is that an EGG definition must use the ASCII 
character set, and that all 128 characters in the ASCII set will be
properly handled by the standard EGG parser.

The second implication is that while an EGG definition must itself use
the ASCII character set, any grammar it defines, and its associated
parser is NOT required to use ASCII as its base character coding. In other
words, a grammar can be defined that is specific to a locale's character
set, but the EGG definition still must use ASCII.  The resulting parser
need not know anything about ASCII to properly parse the defining grammar.

For example, a grammar can be defined in EGG that describes the syntax
for a configuration file that is in the Klingon language.  The resultant
parser will parse the configuration file in Klingon encoding, not needing
to know anything about the ASCII (US English) character set.

NOTE:  The descriptions for each individual ASCII character have been
			 omitted from this section.  Please refer to the canonical EGG
			 definition file for EGG itself, and/or an ASCII table for further
			 details.

@node An Example Grammar Defined in EGG
@section An Example Grammar Defined in EGG
A very simple EGG definition follows:

@example

(* A comment *)
command = add | delete | list ;

add = 'add' + code ;

delete-command = 'delete' | 'del' ;

delete = (* an inline comment *) delete-command + code ;

list = 'list' + code@{0,1@} ;

code = code-chars@{1,*@} ;

code-chars = 'A'|'B'|'C'|'D' ;

@end example

@noindent
An equivalent definition could also be:

@example

(*a very compact example EGG definition*)
command=add|delete|list;
add='add'+code;
delete-command='delete'|'del';
delete=delete-command+code;
list='list'+code@{0,1@};
code=code-chars@{1,*@};
code-chars='A'|'B'|'C'|'D';

@end example

@noindent
In the above example, a grammar has been defined that consists of one
top level phrase named command.

A command can be either an add, delete, or list.

An add is the literal string 'add' followed by a code.

A delete is the literal string 'delete' or the literal string 'del', then
followed by a code.

A list is the literal string 'list' followed by an optional code.

A code is simply a sequence, in any order, or one or more literal 'A', 'B'
'C', or 'D' characters.

In this grammar, all of the following examples would parse without error:

 addABCD
 delABCD
 list
 listABCD
 addC
 addCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCBBBBCCCCCCCCCA

but, the following would cause a parser failure:

 add ABCD  (Note that the example grammar does not allow for spaces)
 add       (A code is required)

@node embryo
@chapter embryo
@menu
* embryo Purpose::
* embryo Invocation::
* embryo Options Explained::
* embryo Output::
* embryo Examples::
@end menu

@node embryo Purpose
@section Purpose

@node embryo Invocation
@section Invocation

@node embryo Options Explained
@section Options Explained

@node embryo Output
@section Output

@node embryo Examples
@section Examples

@node embryo Output Explained
@chapter embryo Output Explained

@node egg-walker
@chapter egg-walker
@menu
* egg-walker Purpose::
* egg-walker Invocation::
* egg-walker Options Explained::
* egg-walker Output::
* egg-walker Examples::
@end menu

@node egg-walker Purpose
@section Purpose

@node egg-walker Invocation
@section Invocation

@node egg-walker Options Explained
@section Options Explained

@node egg-walker Output
@section Output

@node egg-walker Examples
@section Examples

@node egg-walker Output Explained
@chapter egg-walker Output Explained

@node egg-mapper
@chapter egg-mapper
@menu
* egg-mapper Purpose::
* egg-mapper Invocation::
* egg-mapper Options Explained::
* egg-mapper Output::
* egg-mapper Examples::
@end menu

@node egg-mapper Purpose
@section Purpose

@node egg-mapper Invocation
@section Invocation

@node egg-mapper Options Explained
@section Options Explained

@node egg-mapper Output
@section Output

@node egg-mapper Examples
@section Examples

@node egg-mapper Output Explained
@chapter egg-mapper Output Explained

@node Tutorial - Creating a parser from an EGG
@chapter Tutorial - Creating a parser from an EGG
@menu
* Simple Example::
* An EGG EGG::
* SPICE model::
@end menu

@node Simple Example
@section Simple Example

@node An EGG EGG
@section An EGG EGG

@node SPICE model
@section SPICE model

@node Terms
@appendix Terms

@node Bibliography
@unnumbered Bibliography

@node Index
@unnumbered Index

@printindex cp

@bye
